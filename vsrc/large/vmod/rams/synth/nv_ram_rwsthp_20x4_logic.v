// nv_ram_rwsthp_20x4: synthesizable model core
// Generated by /home/nvtools/branch/release/t194_rg/2017/06/01_10_25_11/nvtools/rams/scripts/ramgen - DO NOT EDIT
// Estimated area: 174.18 um^2 (nvstd_tsmc16fflr)
`ifdef _SIMULATE_X_VH_
`else
`ifndef SYNTHESIS
`define tick_x_or_0 1'bx
`define tick_x_or_1 1'bx
`else
`define tick_x_or_0 1'b0
`define tick_x_or_1 1'b1
`endif
`endif
// verilint 549 off - async flop inferred
// verilint 446 off - reading from output port
// verilint 389 off - multiple clocks in module
// verilint 287 off - unconnected ports
// verilint 401 off - Clock is not an input to the module (we use gated clk)
// verilint 257 off - delays ignored by synth tools
// verilint 240 off - Unused input
// verilint 542 off - enabled flop inferred
// verilint 210 off - too few module ports
// verilint 280 off - delay in non-blocking assignment
// verilint 332 off - not all possible cases covered, but default case exists
// verilint 390 off - multiple resets in this module
// verilint 396 off - flop w/o async reset
// verilint 69 off - case without default, all cases covered
// verilint 34 off - unused macro
// verilint 528 off - variable set but not used
// verilint 530 off - flop inferred
// verilint 550 off - mux inferred
// verilint 113 off - multiple drivers to flop
// leda ELB072 off
`timescale 1ns / 10ps
module nv_ram_rwsthp_20x4_logic (
               byp_sel,
               clk,
               dbyp,
               di,
               dout,
               ore,
               pwrbus_ram_pd,
               ra,
               re,
               scan_en,
               wa,
               we
        );
parameter FORCE_CONTENTION_ASSERTION_RESET_ACTIVE=1'b0;
// port list for submodule
input byp_sel;
input clk;
input [3:0] dbyp;
input [3:0] di;
output [3:0] dout;
input ore;
input [31:0] pwrbus_ram_pd;
input [4:0] ra;
input re;
input scan_en;
input [4:0] wa;
input we;
wire [7:0] sleep_en = pwrbus_ram_pd[7:0];
wire ret_en = pwrbus_ram_pd[8];
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_9 (.A(pwrbus_ram_pd[9]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_10 (.A(pwrbus_ram_pd[10]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_11 (.A(pwrbus_ram_pd[11]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_12 (.A(pwrbus_ram_pd[12]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_13 (.A(pwrbus_ram_pd[13]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_14 (.A(pwrbus_ram_pd[14]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_15 (.A(pwrbus_ram_pd[15]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_16 (.A(pwrbus_ram_pd[16]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_17 (.A(pwrbus_ram_pd[17]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_18 (.A(pwrbus_ram_pd[18]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_19 (.A(pwrbus_ram_pd[19]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_20 (.A(pwrbus_ram_pd[20]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_21 (.A(pwrbus_ram_pd[21]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_22 (.A(pwrbus_ram_pd[22]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_23 (.A(pwrbus_ram_pd[23]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_24 (.A(pwrbus_ram_pd[24]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_25 (.A(pwrbus_ram_pd[25]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_26 (.A(pwrbus_ram_pd[26]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_27 (.A(pwrbus_ram_pd[27]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_28 (.A(pwrbus_ram_pd[28]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_29 (.A(pwrbus_ram_pd[29]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_30 (.A(pwrbus_ram_pd[30]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_31 (.A(pwrbus_ram_pd[31]));
reg [4:0] Ra_array_reg_r0;
// Declare the Data_reg signal beforehand
// verilint 498 off - not all bits are used
reg [3:0] Data_reg_r0;
// Data out bus for read port r0 for Output Mux
wire [3:0] r0_OutputMuxDataOut;
reg [4:0] Ra_reg_r0;
// Write enable bus
wire we_0_0;
// start of predeclareNvregSignals
wire ctx_ctrl_we;
wire [4:0] D_Ra_array_reg_r0;
wire [4:0] la_muxedRa_r0;
assign D_Ra_array_reg_r0 = ( ((re))) ? ra : Ra_array_reg_r0;
always @(posedge clk) begin
    Ra_array_reg_r0 <= D_Ra_array_reg_r0;
 end
assign la_muxedRa_r0 = Ra_array_reg_r0;
// ------------------ START PIECE ----------------------------------
// Suffix : Piece Flop_Array (FlopArray)
// Covers Addresses from 0 to 19 Addressrange: [4:0]
// Data Bit range: [3:0] (4 bits)
// Enables: 1 Enable range:
// Write Address bus
wire [4:0] wa_0_0;
assign wa_0_0 = wa;
// Write Data in bus
wire [3:0] di_0_0;
assign di_0_0 = di[3:0];
assign we_0_0 = we;
// Read Address bus
wire [4:0] ra_0_0;
assign ra_0_0 = la_muxedRa_r0;
// Read DataOut bus
wire [3:0] dout_0_0;
// begin ---------------- Flop_Array ---------------
// Declare the register array
reg [3:0] FlopArray_row0;
reg [3:0] FlopArray_row1;
reg [3:0] FlopArray_row2;
reg [3:0] FlopArray_row3;
reg [3:0] FlopArray_row4;
reg [3:0] FlopArray_row5;
reg [3:0] FlopArray_row6;
reg [3:0] FlopArray_row7;
reg [3:0] FlopArray_row8;
reg [3:0] FlopArray_row9;
reg [3:0] FlopArray_row10;
reg [3:0] FlopArray_row11;
reg [3:0] FlopArray_row12;
reg [3:0] FlopArray_row13;
reg [3:0] FlopArray_row14;
reg [3:0] FlopArray_row15;
reg [3:0] FlopArray_row16;
reg [3:0] FlopArray_row17;
reg [3:0] FlopArray_row18;
reg [3:0] FlopArray_row19;
// Declare the Write port wires
// Write Data wires
wire [3:0] Wdata;
// Assign for data input
assign Wdata = di_0_0;
// Address decode for Flop array
wire [19:0] Wa_decode;
// Create wire for one write enable
wire We;
assign We = we_0_0;
assign Wa_decode[0] = We & (wa_0_0 == 5'd0);
assign Wa_decode[1] = We & (wa_0_0 == 5'd1);
assign Wa_decode[2] = We & (wa_0_0 == 5'd2);
assign Wa_decode[3] = We & (wa_0_0 == 5'd3);
assign Wa_decode[4] = We & (wa_0_0 == 5'd4);
assign Wa_decode[5] = We & (wa_0_0 == 5'd5);
assign Wa_decode[6] = We & (wa_0_0 == 5'd6);
assign Wa_decode[7] = We & (wa_0_0 == 5'd7);
assign Wa_decode[8] = We & (wa_0_0 == 5'd8);
assign Wa_decode[9] = We & (wa_0_0 == 5'd9);
assign Wa_decode[10] = We & (wa_0_0 == 5'd10);
assign Wa_decode[11] = We & (wa_0_0 == 5'd11);
assign Wa_decode[12] = We & (wa_0_0 == 5'd12);
assign Wa_decode[13] = We & (wa_0_0 == 5'd13);
assign Wa_decode[14] = We & (wa_0_0 == 5'd14);
assign Wa_decode[15] = We & (wa_0_0 == 5'd15);
assign Wa_decode[16] = We & (wa_0_0 == 5'd16);
assign Wa_decode[17] = We & (wa_0_0 == 5'd17);
assign Wa_decode[18] = We & (wa_0_0 == 5'd18);
assign Wa_decode[19] = We & (wa_0_0 == 5'd19);
reg [3:0] RaDecodeDor0;
// Assign the input data to the flop input
wire [3:0] FlopArray_row0_d;
assign FlopArray_row0_d = (Wa_decode[0]) ? Wdata : FlopArray_row0;
wire [3:0] FlopArray_row1_d;
assign FlopArray_row1_d = (Wa_decode[1]) ? Wdata : FlopArray_row1;
wire [3:0] FlopArray_row2_d;
assign FlopArray_row2_d = (Wa_decode[2]) ? Wdata : FlopArray_row2;
wire [3:0] FlopArray_row3_d;
assign FlopArray_row3_d = (Wa_decode[3]) ? Wdata : FlopArray_row3;
wire [3:0] FlopArray_row4_d;
assign FlopArray_row4_d = (Wa_decode[4]) ? Wdata : FlopArray_row4;
wire [3:0] FlopArray_row5_d;
assign FlopArray_row5_d = (Wa_decode[5]) ? Wdata : FlopArray_row5;
wire [3:0] FlopArray_row6_d;
assign FlopArray_row6_d = (Wa_decode[6]) ? Wdata : FlopArray_row6;
wire [3:0] FlopArray_row7_d;
assign FlopArray_row7_d = (Wa_decode[7]) ? Wdata : FlopArray_row7;
wire [3:0] FlopArray_row8_d;
assign FlopArray_row8_d = (Wa_decode[8]) ? Wdata : FlopArray_row8;
wire [3:0] FlopArray_row9_d;
assign FlopArray_row9_d = (Wa_decode[9]) ? Wdata : FlopArray_row9;
wire [3:0] FlopArray_row10_d;
assign FlopArray_row10_d = (Wa_decode[10]) ? Wdata : FlopArray_row10;
wire [3:0] FlopArray_row11_d;
assign FlopArray_row11_d = (Wa_decode[11]) ? Wdata : FlopArray_row11;
wire [3:0] FlopArray_row12_d;
assign FlopArray_row12_d = (Wa_decode[12]) ? Wdata : FlopArray_row12;
wire [3:0] FlopArray_row13_d;
assign FlopArray_row13_d = (Wa_decode[13]) ? Wdata : FlopArray_row13;
wire [3:0] FlopArray_row14_d;
assign FlopArray_row14_d = (Wa_decode[14]) ? Wdata : FlopArray_row14;
wire [3:0] FlopArray_row15_d;
assign FlopArray_row15_d = (Wa_decode[15]) ? Wdata : FlopArray_row15;
wire [3:0] FlopArray_row16_d;
assign FlopArray_row16_d = (Wa_decode[16]) ? Wdata : FlopArray_row16;
wire [3:0] FlopArray_row17_d;
assign FlopArray_row17_d = (Wa_decode[17]) ? Wdata : FlopArray_row17;
wire [3:0] FlopArray_row18_d;
assign FlopArray_row18_d = (Wa_decode[18]) ? Wdata : FlopArray_row18;
wire [3:0] FlopArray_row19_d;
assign FlopArray_row19_d = (Wa_decode[19]) ? Wdata : FlopArray_row19;
always @(posedge clk) begin
   FlopArray_row0 <= FlopArray_row0_d;
   FlopArray_row1 <= FlopArray_row1_d;
   FlopArray_row2 <= FlopArray_row2_d;
   FlopArray_row3 <= FlopArray_row3_d;
   FlopArray_row4 <= FlopArray_row4_d;
   FlopArray_row5 <= FlopArray_row5_d;
   FlopArray_row6 <= FlopArray_row6_d;
   FlopArray_row7 <= FlopArray_row7_d;
   FlopArray_row8 <= FlopArray_row8_d;
   FlopArray_row9 <= FlopArray_row9_d;
   FlopArray_row10 <= FlopArray_row10_d;
   FlopArray_row11 <= FlopArray_row11_d;
   FlopArray_row12 <= FlopArray_row12_d;
   FlopArray_row13 <= FlopArray_row13_d;
   FlopArray_row14 <= FlopArray_row14_d;
   FlopArray_row15 <= FlopArray_row15_d;
   FlopArray_row16 <= FlopArray_row16_d;
   FlopArray_row17 <= FlopArray_row17_d;
   FlopArray_row18 <= FlopArray_row18_d;
   FlopArray_row19 <= FlopArray_row19_d;
end
// Declare the Do buses for data out.
// Do Ra decode
always @(ra_0_0 or FlopArray_row0 or FlopArray_row1 or FlopArray_row2 or
         FlopArray_row3 or FlopArray_row4 or FlopArray_row5 or FlopArray_row6 or
         FlopArray_row7 or FlopArray_row8 or FlopArray_row9 or FlopArray_row10 or
         FlopArray_row11 or FlopArray_row12 or FlopArray_row13 or
         FlopArray_row14 or FlopArray_row15 or FlopArray_row16 or
         FlopArray_row17 or FlopArray_row18 or FlopArray_row19)
// verilint 332 off - not all cases covered, default exists
   case(ra_0_0)
       5'd0 : RaDecodeDor0 = FlopArray_row0;
       5'd1 : RaDecodeDor0 = FlopArray_row1;
       5'd2 : RaDecodeDor0 = FlopArray_row2;
       5'd3 : RaDecodeDor0 = FlopArray_row3;
       5'd4 : RaDecodeDor0 = FlopArray_row4;
       5'd5 : RaDecodeDor0 = FlopArray_row5;
       5'd6 : RaDecodeDor0 = FlopArray_row6;
       5'd7 : RaDecodeDor0 = FlopArray_row7;
       5'd8 : RaDecodeDor0 = FlopArray_row8;
       5'd9 : RaDecodeDor0 = FlopArray_row9;
       5'd10 : RaDecodeDor0 = FlopArray_row10;
       5'd11 : RaDecodeDor0 = FlopArray_row11;
       5'd12 : RaDecodeDor0 = FlopArray_row12;
       5'd13 : RaDecodeDor0 = FlopArray_row13;
       5'd14 : RaDecodeDor0 = FlopArray_row14;
       5'd15 : RaDecodeDor0 = FlopArray_row15;
       5'd16 : RaDecodeDor0 = FlopArray_row16;
       5'd17 : RaDecodeDor0 = FlopArray_row17;
       5'd18 : RaDecodeDor0 = FlopArray_row18;
       5'd19 : RaDecodeDor0 = FlopArray_row19;
       default :RaDecodeDor0 = {4{`tick_x_or_0}};
    endcase
// verilint 332 on
assign dout_0_0 = RaDecodeDor0;
//------------ Done generating flop array Flop_Array -------------
// ---------------------------------------------
// Declare the interface wires for Output Mux logic
// verilint 552 off - Different bits of a net are driven in different blocks (harmless,
// but some synthesis tools generate a warning for this)
reg [3:0] ram_r0_OutputMuxDataOut;
//For bitEnd 3, only one piece Flop_Array in the column.
// verilint 17 off - Range (rather than full vector) in the sensitivity list
always @(dout_0_0)
      ram_r0_OutputMuxDataOut[3:0] = dout_0_0;
assign r0_OutputMuxDataOut[3:0] = ram_r0_OutputMuxDataOut[3:0];
// verilint 17 on - Range (rather than full vector) in the sensitivity list
// --------------------- Output Mbist Interface logic -------------
wire [3:0] functional_byp_r0_OutputMuxDataOut = (byp_sel) ? dbyp : r0_OutputMuxDataOut;
wire [3:0] muxed_r0_OutputMuxDataOut;
assign muxed_r0_OutputMuxDataOut = ( | (byp_sel)) ? functional_byp_r0_OutputMuxDataOut : r0_OutputMuxDataOut;
wire captureDR_r0 = ((((ore))) || ( 1'b0 ));
////MSB 3 LSB 0  and total rambit is 0 and  dsize is 4
always @(posedge clk) begin
    if (captureDR_r0)
       Data_reg_r0[3:0] <= muxed_r0_OutputMuxDataOut[3:0];
end
assign dout = Data_reg_r0;
// Ram access scan chain
`ifdef ASSERT_ON
`ifndef SYNTHESIS
reg sim_reset_;
initial sim_reset_ = 0;
always @(posedge clk) sim_reset_ <= 1'b1;
wire start_of_sim = sim_reset_;
wire disable_clk_x_test = $test$plusargs ("disable_clk_x_test") ? 1'b1 : 1'b0;
nv_assert_no_x #(1,1,0," Try Reading Ram when clock is x for read port r0") _clk_x_test_read (clk, sim_reset_, ((disable_clk_x_test===1'b0) && (|re===1'b1 )), clk);
nv_assert_no_x #(1,1,0," Try Writing Ram when clock is x for write port w0") _clk_x_test_write (clk, sim_reset_, ((disable_clk_x_test===1'b0) && (|we===1'b1)), clk);
`endif // SYNTHESIS 
`endif // ASSERT_ON
`ifdef ASSERT_ON
`ifndef SYNTHESIS
`endif
`endif
`ifdef ASSERT_ON
`ifndef SYNTHESIS
wire pwrbus_assertion_not_x_while_active = $test$plusargs ("pwrbus_assertion_not_x_while_active");
nv_assert_never #(0, 0, "Power bus cannot be X when read/write enable is set") _pwrbus_assertion_not_x_while_active_we ( we, sim_reset_ && !pwrbus_assertion_not_x_while_active, ^pwrbus_ram_pd === 1'bx);
nv_assert_never #(0, 0, "Power bus cannot be X when read/write enable is set") _pwrbus_assertion_not_x_while_active_re ( re, sim_reset_ && !pwrbus_assertion_not_x_while_active, ^pwrbus_ram_pd === 1'bx);
`endif
`endif
// submodule done
endmodule
